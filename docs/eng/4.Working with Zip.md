# Working with ZIP Archives in TheMakarik.Testing.FileSystem

`TheMakarik.Testing.FileSystem` provides a convenient interface for creating and verifying the contents of ZIP archives in integration tests. This allows testing scenarios related to compressed files and archives without manually creating and extracting archives.

## Creating ZIP Archives

### Main Method `AddZip`

The `AddZip` extension method is used to create ZIP archives and add them to the file system.

#### 1) Creating a ZIP Archive
```csharp
public static IFileSystemBuilder AddZip(
    this IFileSystemBuilder builder, 
    string archiveName, 
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder>? builderAction)
```

Creates a ZIP archive with the specified name in the file system. If `builderAction` is not provided, an empty archive is created.

**Example:**
```csharp
_fileSystem = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddZip("data.zip", zipBuilder => zipBuilder
        .AddFile("config.json", "{ \"enabled\": true }")
        .AddDirectory("logs", logsBuilder => logsBuilder
            .AddFile("app.log", "Log content")))
    .Build();
```

#### 2) Creating a ZIP Archive and Getting Its Full Path
```csharp
public static IFileSystemBuilder AddZip(
    this IFileSystemBuilder builder, 
    string archiveName, 
    out string archiveFullPath,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder>? builderAction)
```

Creates a ZIP archive and returns its full path via the `out` parameter.

**Example:**
```csharp
string zipPath;
_fileSystem = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddZip("archive.zip", out zipPath, zipBuilder => zipBuilder
        .AddFile("readme.txt", "Archive content"))
    .Build();
```

### Creating Multiple ZIP Archives

#### 3) Creating Multiple ZIP Archives
```csharp
public static IFileSystemBuilder AddZips(
    this IFileSystemBuilder builder,
    string[] archiveNames,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder>? builderAction = null)
```

Creates multiple ZIP archives with identical content structure.

**Example:**
```csharp
_fileSystem = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddZips(["backup.zip", "data.zip", "logs.zip"], zipBuilder => zipBuilder
        .AddFile("metadata.txt", "Created: " + DateTime.Now))
    .Build();
```

#### 4) Creating Multiple ZIP Archives and Getting Their Paths
```csharp
public static IFileSystemBuilder AddZips(
    this IFileSystemBuilder builder,
    string[] archiveNames,
    out string[] archiveFullPaths,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder>? builderAction = null)
```

Creates multiple ZIP archives and returns an array of their full paths.

**Example:**
```csharp
string[] archivePaths;
_fileSystem = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddZips(["archive1.zip", "archive2.zip"], out archivePaths, zipBuilder => zipBuilder
        .AddFile("info.txt", "Archive data"))
    .Build();
```

## Adding Files to ZIP Archives

### Adding Individual Files

#### 1) Adding an Empty File
```csharp
public static IZipArchiveFileSystemBuilder AddFile(
    this IZipArchiveFileSystemBuilder builder, 
    string fileName, 
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Adds an empty file to the ZIP archive with the specified compression level.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFile("empty.txt", CompressionLevel.Fastest))
```

#### 2) Adding a File with Content
```csharp
public static IZipArchiveFileSystemBuilder AddFile(
    this IZipArchiveFileSystemBuilder builder, 
    string fileName, 
    string content, 
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Adds a file with the specified content to the ZIP archive.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFile("config.json", "{ \"key\": \"value\" }", CompressionLevel.Optimal))
```

#### 3) Adding a File and Getting Its Relative Path
```csharp
public static IZipArchiveFileSystemBuilder AddFile(
    this IZipArchiveFileSystemBuilder builder, 
    string fileName, 
    out string entryRelativePath,
    string content, 
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Adds a file and returns its relative path inside the archive.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFile("data.txt", out string relativePath, "File content"))
// relativePath contains the file path inside the archive, e.g., "data.txt"
```

### Adding Multiple Files

#### 4) Adding Multiple Empty Files
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Adds multiple empty files to the ZIP archive.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFiles(["file1.txt", "file2.txt", "file3.txt"], CompressionLevel.Fastest))
```

#### 5) Adding Multiple Empty Files and Getting Their Paths
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    out string[] entriesRelativePaths,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Adds multiple empty files and returns their relative paths inside the archive.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFiles(["a.txt", "b.txt"], out string[] paths))
// paths contains ["a.txt", "b.txt"]
```

#### 6) Adding Multiple Files with the Same Content
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    string content,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Adds multiple files with identical content.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFiles(["log1.txt", "log2.txt"], "Log entry", CompressionLevel.Optimal))
```

#### 7) Adding Multiple Files with Content and Getting Their Paths
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    out string[] entriesRelativePaths,
    string content,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Adds multiple files with identical content and returns their relative paths.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFiles(["data1.csv", "data2.csv"], out string[] paths, "csv,data"))
```

## Adding Directories to ZIP Archives

### Adding Individual Directories

#### 1) Adding a Directory with Nested Content
```csharp
public static IZipArchiveFileSystemBuilder AddDirectory(
    this IZipArchiveFileSystemBuilder builder, 
    string directoryName, 
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder> createDirectory)
```

Adds a directory with nested content to the ZIP archive.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddDirectory("config", dirBuilder => dirBuilder
        .AddFile("settings.json", "{}")
        .AddFile("secrets.env", "KEY=SECRET")))
```

#### 2) Adding a Directory and Getting Its Relative Path
```csharp
public static IZipArchiveFileSystemBuilder AddDirectory(
    this IZipArchiveFileSystemBuilder builder, 
    string directoryName, 
    out string directoryRelativePath,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder> createDirectory)
```

Adds a directory and returns its relative path inside the archive.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddDirectory("logs", out string logPath, logsBuilder => logsBuilder
        .AddFile("app.log")))
// logPath contains "logs/"
```

### Adding Multiple Directories

#### 3) Adding Multiple Directories
```csharp
public static IZipArchiveFileSystemBuilder AddDirectories(
    this IZipArchiveFileSystemBuilder builder,
    string[] directoryNames,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder> createDirectory)
```

Adds multiple directories with identical content structure.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddDirectories(["2024-01", "2024-02", "2024-03"], monthBuilder => monthBuilder
        .AddFile("report.txt", "Monthly report")))
```

#### 4) Adding Multiple Directories and Getting Their Paths
```csharp
public static IZipArchiveFileSystemBuilder AddDirectories(
    this IZipArchiveFileSystemBuilder builder,
    string[] directoryNames,
    out string[] directoriesRelativePaths,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder> createDirectory)
```

Adds multiple directories and returns their relative paths inside the archive.

**Example:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddDirectories(["src", "tests", "docs"], out string[] paths, dirBuilder => dirBuilder
        .AddFile("README.md")))
// paths contains ["src/", "tests/", "docs/"]
```

## Verifying ZIP Archive Contents

### Method `ShouldZip`

The `ShouldZip` method is used to verify ZIP archive contents. It extracts the archive to a temporary directory and creates an assertion context.

```csharp
public static IFileSystemAssertion ShouldZip(
    this IFileSystem fileSystem, 
    string rootRelativeZipArchiveName)
```

Extracts the specified ZIP archive and returns an assertion context for verifying its contents.

**Example:**
```csharp
[Fact]
public void ZipArchive_ShouldContainRequiredFiles()
{
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZip("data.zip", zipBuilder => zipBuilder
            .AddFile("config.json", "{}")
            .AddDirectory("logs", logsBuilder => logsBuilder
                .AddFile("app.log", "log content")))
        .Build();
    
    fileSystem.ShouldZip("data.zip")
        .FileExists("config.json")
        .DirectoryExists("logs")
        .FileContains("logs/app.log", "log content");
}
```

## Usage Examples

### Example 1: Testing Backups
```csharp
[Fact]
public void BackupArchive_ShouldContainAllData()
{
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZip("backup.zip", out string backupPath, zipBuilder => zipBuilder
            .AddFiles(["users.csv", "products.csv"], "CSV data")
            .AddDirectory("logs", logsBuilder => logsBuilder
                .AddFiles(["app.log", "error.log"], "Log entry"))
            .AddDirectory("config", configBuilder => configBuilder
                .AddFile("settings.json", "{\"backup\": true}")))
        .Build();
    
    fileSystem.ShouldZip("backup.zip")
        .TotalFileCount(5)
        .DirectoryExists("logs")
        .DirectoryExists("config")
        .FileExists("users.csv")
        .FileExists("products.csv")
        .FileContains("config/settings.json", "backup");
}
```

### Example 2: Testing Compression with Different Levels
```csharp
[Fact]
public void Archive_ShouldUseDifferentCompressionLevels()
{
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZip("archive.zip", zipBuilder => zipBuilder
            .AddFile("fast.txt", "Fast compression", CompressionLevel.Fastest)
            .AddFile("optimal.txt", "Optimal compression", CompressionLevel.Optimal)
            .AddFile("small.txt", "No compression", CompressionLevel.NoCompression))
        .Build();
    
    fileSystem.ShouldZip("archive.zip")
        .FileExists("fast.txt")
        .FileExists("optimal.txt")
        .FileExists("small.txt")
        .FileContentEquals("fast.txt", "Fast compression")
        .FileContentEquals("optimal.txt", "Optimal compression")
        .FileContentEquals("small.txt", "No compression");
}
```

### Example 3: Testing Complex Archive Structures
```csharp
[Fact]
public void MultiArchive_ProjectStructure()
{
    string[] archivePaths;
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZips(["source.zip", "docs.zip", "tests.zip"], out archivePaths, zipBuilder => zipBuilder
            .AddDirectory("src", srcBuilder => srcBuilder
                .AddFiles(["Program.cs", "Startup.cs"], "C# code", CompressionLevel.Optimal)
                .AddDirectory("Models", modelsBuilder => modelsBuilder
                    .AddFile("User.cs", "public class User {}")))
            .AddFile("README.md", "Project documentation"))
        .Build();
    
    // Verifying the first archive
    fileSystem.ShouldZip("source.zip")
        .DirectoryExists("src")
        .DirectoryExists("src/Models")
        .FileExists("src/Program.cs")
        .FileExists("src/Models/User.cs")
        .FileExists("README.md");
}
```

### Example 4: Testing Nested Archive Structures
```csharp
[Fact]
public void NestedArchiveStructure_ShouldBeValid()
{
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZip("project.zip", zipBuilder => zipBuilder
            .AddDirectory("2024", yearBuilder => yearBuilder
                .AddDirectories(["Q1", "Q2", "Q3", "Q4"], quarterBuilder => quarterBuilder
                    .AddFiles(["report.pdf", "data.xlsx"], "Quarter data")))
            .AddFile("summary.txt", "Annual summary"))
        .Build();
    
    fileSystem.ShouldZip("project.zip")
        .DirectoryExists("2024")
        .DirectoryExists("2024/Q1")
        .DirectoryExists("2024/Q2")
        .DirectoryExists("2024/Q3")
        .DirectoryExists("2024/Q4")
        .FileExists("2024/Q1/report.pdf")
        .FileExists("2024/Q2/data.xlsx")
        .FileExists("summary.txt")
        .TotalFileCount(9); // 4 quarters Ã— 2 files + summary.txt
}
```

## Important Notes

1. **Automatic Cleanup**: Temporary directories created when extracting archives via `ShouldZip` are automatically cleaned up when `Dispose()` is called on the parent file system.

2. **Relative Paths**: All methods with `out` parameters return relative paths inside the archive, not absolute file paths.

3. **Compression Levels**: Different compression levels can be specified for different files within an archive:
    - `CompressionLevel.Fastest` - Fast compression (lower compression ratio)
    - `CompressionLevel.Optimal` - Optimal compression (balance of speed and size)
    - `CompressionLevel.NoCompression` - No compression

4. **Error Handling**: If an exception occurs during archive creation, any partially created archives are automatically deleted to prevent file system pollution.

5. **Fluent Interface**: All methods support method chaining, making the code more readable and expressive.

Using these methods significantly simplifies testing scenarios involving ZIP archives, making tests more readable and maintainable.