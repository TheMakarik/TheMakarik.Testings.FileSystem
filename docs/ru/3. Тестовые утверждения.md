
`TheMakarik.Testing.FileSystem` предоставляет расширенные возможности для проверки состояния файловой системы в интеграционных тестах. Ассерты (утверждения) позволяют удобно проверять содержимое файлов, структуру директорий и другие свойства файловой системы, что делает тестирование более читаемым и поддерживаемым.

Во всех следующих примерах мы будем использовать [xUnit.net](https://xunit.net/?tabs=cs) но вы можете использовать любой тестовый фреймворк который вам по душе, например [NUnit](https://nunit.org/) или [TUnit](https://github.com/thomhurst/TUnit).

## Пример использования ассертов

```csharp
using TheMakarik.Testing.FileSystem;
using Xunit;

namespace LearnFileSystemProject;

// xUnit.net class
public class AssertionExamples : IDisposable
{
    private IFileSystem _fileSystem;
    private string[] _filePaths;
    private string _directory1;

    public AssertionExamples()
    {
        _fileSystem = FileSystem.BeginBuilding()
            .AddRandomInTempRootName()
            .AddFiles(["file-1.txt", "file-2.txt", "file-3.txt"], "Test content", out _filePaths)
            .AddDirectory("dir-1", out _directory1)
            .Build();
    }

    [Fact]
    public void File1_MustHaveContent()
    {
        _fileSystem.Should()
            .FileContentEquals("file-1.txt", "Test content");
    }

    [Fact]
    public void Directory1_MustHaveNoContent()
    {
        _fileSystem
            .Should()
            .HasNoDirectoryContent(_directory1);
    }

    [Fact]
    public void Files_MustExist()
    {
        _fileSystem.Should()
            .FileExists("file-1.txt")
            .FileExists("file-2.txt")
            .FileExists("file-3.txt");
    }

    [Fact]
    public void ConfigFile_MustBeValidJson()
    {
        var testFileSystem = FileSystem.BeginBuilding()
            .AddRandomInTempRootName()
            .AddFile("config.json", "{ \"enabled\": true, \"timeout\": 30 }")
            .Build();

        testFileSystem.Should()
            .FileExists("config.json")
            .FileContains("config.json", "enabled")
            .FileMatchesRegex("config.json", "\"timeout\"\\s*:\\s*30");
        
        testFileSystem.Dispose();
    }

    public void Dispose()
    {
        _fileSystem.Dispose();
    }
}
```

Методы ассертов работают с fluent интерфейсом и имеют следующие перегрузки и категории.

## Основные методы ассертов

### Метод Should()
```csharp
public static IFileSystemAssertion Should(this IFileSystem fileSystem)
```
Создает экземпляр ассерта для указанной файловой системы. Все последующие проверки будут выполняться относительно корневой директории этой файловой системы.

## Проверки существования файлов и директорий

### 1) Проверка существования файла или директории
```csharp
public static IFileSystemAssertion Contains(this IFileSystemAssertion assertion, string rootRelativePath)
```
Проверяет что файл или директория существует по указанному пути. `string rootRelativePath` - относительный путь от корневой директории.

**Пример:**
```csharp
_fileSystem.Should().Contains("file.txt");
```

### 2) Проверка отсутствия файла или директории
```csharp
public static IFileSystemAssertion NotContains(this IFileSystemAssertion assertion, string rootRelativePath)
```
Проверяет что файл или директория НЕ существует по указанному пути.

**Пример:**
```csharp
_fileSystem.Should().NotContains("deleted-file.txt");
```

### 3) Проверка существования конкретного файла
```csharp
public static IFileSystemAssertion FileExists(this IFileSystemAssertion assertion, string rootRelativePath)
```
Проверяет что по указанному пути существует именно файл (не директория).

**Пример:**
```csharp
_fileSystem.Should().FileExists("config.json");
```

### 4) Проверка существования конкретной директории
```csharp
public static IFileSystemAssertion DirectoryExists(this IFileSystemAssertion assertion, string rootRelativePath)
```
Проверяет что по указанному пути существует именно директория (не файл).

**Пример:**
```csharp
_fileSystem.Should().DirectoryExists("logs");
```

## Проверки содержимого файлов

### 1) Проверка что файл не пустой
```csharp
public static IFileSystemAssertion BeNotEmptyFile(this IFileSystemAssertion assertion, string rootRelativePath)
```
Проверяет что файл существует и содержит хотя бы одну строку.

**Пример:**
```csharp
_fileSystem.Should().BeNotEmptyFile("log.txt");
```

### 2) Проверка точного соответствия содержимого
```csharp
public static IFileSystemAssertion FileContentEquals(
    this IFileSystemAssertion assertion, 
    string rootRelativePath,
    string content)
```
Проверяет что содержимое файла точно соответствует указанной строке. Сравнение выполняется с учетом регистра.

**Пример:**
```csharp
_fileSystem.Should().FileContentEquals("readme.txt", "Hello World!");
```

### 3) Проверка точного соответствия содержимого с указанием сравнения
```csharp
public static IFileSystemAssertion FileContentEquals(
    this IFileSystemAssertion assertion, 
    string rootRelativePath,
    string content,
    StringComparison comparisonType)
```
Проверяет что содержимое файла соответствует указанной строке с использованием заданных правил сравнения.

**Пример:**
```csharp
_fileSystem.Should().FileContentEquals("config.txt", "ENABLED=true", StringComparison.OrdinalIgnoreCase);
```

### 4) Проверка что файл содержит указанный текст
```csharp
public static IFileSystemAssertion FileContains(
    this IFileSystemAssertion assertion, 
    string rootRelativePath, 
    string text, 
    StringComparison stringComparison = StringComparison.Ordinal)
```
Проверяет что файл содержит указанный текст. Можно задать правила сравнения строк.

**Пример:**
```csharp
_fileSystem.Should()
    .FileContains("log.txt", "ERROR")
    .FileContains("config.txt", "localhost", StringComparison.OrdinalIgnoreCase);
```

### 5) Проверка что файл соответствует регулярному выражению
```csharp
public static IFileSystemAssertion FileMatchesRegex(this IFileSystemAssertion assertion, string rootRelativePath, string pattern)
```
Проверяет что содержимое файла соответствует указанному регулярному выражению.

**Пример:**
```csharp
_fileSystem.Should().FileMatchesRegex("config.txt", "^\\s*\\w+\\s*=\\s*\\w+\\s*$");
```

### 6) Проверка что файл начинается с указанного текста
```csharp
public static IFileSystemAssertion FileStartsWith(
    this IFileSystemAssertion assertion, 
    string rootRelativePath, 
    string startingText, 
    StringComparison stringComparison = StringComparison.Ordinal)
```
Проверяет что файл начинается с указанного текста.

**Пример:**
```csharp
_fileSystem.Should().FileStartsWith("script.sh", "#!/bin/bash");
```

### 7) Проверка что файл заканчивается указанным текстом
```csharp
public static IFileSystemAssertion FileEndsWith(
    this IFileSystemAssertion assertion, 
    string rootRelativePath, 
    string endingText, 
    StringComparison stringComparison = StringComparison.Ordinal)
```
Проверяет что файл заканчивается указанным текстом.

**Пример:**
```csharp
_fileSystem.Should().FileEndsWith("data.json", "\n}");
```

## Проверки размера файлов

### 1) Проверка что файл пустой
```csharp
public static IFileSystemAssertion FileIsEmpty(this IFileSystemAssertion assertion, string rootRelativePath)
```
Проверяет что файл существует и имеет размер 0 байт.

**Пример:**
```csharp
_fileSystem.Should().FileIsEmpty("placeholder.txt");
```

### 2) Проверка размера файла
```csharp
public static IFileSystemAssertion FileHasSize(this IFileSystemAssertion assertion, string rootRelativePath, long expectedSize)
```
Проверяет что файл имеет указанный размер в байтах.

**Пример:**
```csharp
_fileSystem.Should().FileHasSize("data.bin", 1024); // 1KB
```

## Проверки дат файлов

### 1) Проверка что файл был изменен после указанной даты
```csharp
public static IFileSystemAssertion FileModifiedAfter(this IFileSystemAssertion assertion, string rootRelativePath, DateTime dateTime)
```
Проверяет что файл был изменен после указанной даты и времени.

**Пример:**
```csharp
_fileSystem.Should().FileModifiedAfter("log.txt", DateTime.Now.AddHours(-1));
```

### 2) Проверка что файл был создан до указанной даты
```csharp
public static IFileSystemAssertion FileCreatedBefore(this IFileSystemAssertion assertion, string rootRelativePath, DateTime dateTime)
```
Проверяет что файл был создан до указанной даты и времени.

**Пример:**
```csharp
_fileSystem.Should().FileCreatedBefore("archive.zip", DateTime.Now.AddDays(-7));
```

## Проверки атрибутов файлов

### 1) Проверка наличия атрибутов файла
```csharp
public static IFileSystemAssertion FileHasAttributes(this IFileSystemAssertion assertion, string rootRelativePath, FileAttributes attributes)
```
Проверяет что файл имеет указанные атрибуты.

**Пример:**
```csharp
_fileSystem.Should().FileHasAttributes("script.sh", FileAttributes.Archive | FileAttributes.ReadOnly);
```

### 2) Проверка отсутствия атрибутов файла
```csharp
public static IFileSystemAssertion FileDoesNotHaveAttributes(this IFileSystemAssertion assertion, string rootRelativePath, FileAttributes attributes)
```
Проверяет что файл НЕ имеет указанных атрибутов.

**Пример:**
```csharp
_fileSystem.Should().FileDoesNotHaveAttributes("data.txt", FileAttributes.Hidden);
```

## Проверки директорий

### 1) Проверка что директория пустая
```csharp
public static IFileSystemAssertion HasNoDirectoryContent(this IFileSystemAssertion assertion, string? rootRelativePath = null)
```
Проверяет что директория не содержит файлов или поддиректорий. Если параметр не указан, проверяет корневую директорию.

**Пример:**
```csharp
_fileSystem.Should()
    .HasNoDirectoryContent("empty-dir")
    .HasNoDirectoryContent(); // Проверяет корневую директорию
```

### 2) Проверка количества файлов в директории
```csharp
public static IFileSystemAssertion DirectoryHasFileCount(this IFileSystemAssertion assertion, string rootRelativePath, int expectedCount)
```
Проверяет что директория содержит указанное количество файлов.

**Пример:**
```csharp
_fileSystem.Should().DirectoryHasFileCount("logs", 5);
```

### 3) Проверка наличия файлов с определенным расширением
```csharp
public static IFileSystemAssertion DirectoryContainsFileWithExtension(this IFileSystemAssertion assertion, string rootRelativePath, string extension)
```
Проверяет что директория содержит хотя бы один файл с указанным расширением.

**Пример:**
```csharp
_fileSystem.Should().DirectoryContainsFileWithExtension("documents", ".pdf");
```

## Сравнение файлов

### 1) Сравнение двух файлов
```csharp
public static IFileSystemAssertion FilesAreEqual(this IFileSystemAssertion assertion, string firstFilePath, string secondFilePath)
```
Проверяет что содержимое двух файлов идентично (побайтовое сравнение).

**Пример:**
```csharp
_fileSystem.Should().FilesAreEqual("original.txt", "backup.txt");
```

## Пользовательские проверки


### 1) Пользовательская проверка элемента
```csharp
public static IFileSystemAssertion ItemBe(this IFileSystemAssertion assertion, string rootRelativePath, Predicate<string> predicate)
```
Позволяет выполнить пользовательскую проверку с помощью указанного предиката. Предикат получает полный путь к файлу или директории.

*Этот метод также можно использовать для создания кастомных методов расширения для ассертов, хотя все же рекомендуется использовать низкоуровневый Validate() о котором будет рассказано далее, из-за невозможности контролировать сообщение об ошибке*

**Пример:**
```csharp
_fileSystem.Should().ItemBe("data.csv", path => 
{
    var content = File.ReadAllText(path);
    return content.Contains("Total") && content.EndsWith("\n");
});
```

### 2) Пользовательская проверка корневой директории файловой системы
```csharp
public static IFileSystemAssertion Be(this IFileSystemAssertion assertion, Predicate<IFileSystem> predicate)
```
Позволяет выполнить пользовательскую проверку всей файловой системы. Предикат получает экземпляр `IFileSystem`, что позволяет проверять любые аспекты файловой системы.

*Этот метод особенно полезен для комплексных проверок, которые затрагивают всю структуру файловой системы или требуют доступа к корневой директории*

**Пример:**
```csharp
_fileSystem.Should().Be(fileSystem => 
{
    // Проверяем, что корневая директория существует
    if (!Directory.Exists(fileSystem.Root))
        return false;
    
    // Проверяем общий размер всех файлов
    var allFiles = Directory.GetFiles(fileSystem.Root, "*", SearchOption.AllDirectories);
    var totalSize = allFiles.Sum(file => new FileInfo(file).Length);
    
    // Ограничиваем общий размер 10MB
    return totalSize < 10 * 1024 * 1024;
});
```

**Дополнительный пример с проверкой структуры проекта:**
```csharp
_fileSystem.Should().Be(fileSystem => 
{
    var root = fileSystem.Root;
    
    // Проверяем наличие обязательных директорий
    var requiredDirectories = new[] { "src", "tests", "docs", "config" };
    foreach (var dir in requiredDirectories)
    {
        if (!Directory.Exists(Path.Combine(root, dir)))
            return false;
    }
    
    // Проверяем наличие README файла
    if (!File.Exists(Path.Combine(root, "README.md")))
        return false;
    
    // Проверяем что нет временных файлов в корне
    var tempFiles = Directory.GetFiles(root, "*.tmp");
    return tempFiles.Length == 0;
});
```

**Пример с проверкой прав доступа:**
```csharp
_fileSystem.Should().Be(fileSystem => 
{
    var root = fileSystem.Root;
    var directories = Directory.GetDirectories(root);
    
    // Проверяем что все директории доступны для чтения
    foreach (var dir in directories)
    {
        try
        {
            Directory.GetFiles(dir);
        }
        catch (UnauthorizedAccessException)
        {
            return false; // Нет доступа к директории
        }
    }
    
    return true;
});
```

**Key differences between `ItemBe` and `Be`:**
- `ItemBe` validates a specific file or directory at a relative path
- `Be` validates the entire file system instance, giving access to the root directory and full control over validation logic
- `Be` is ideal for global constraints and structural validations
- `ItemBe` is better for validating specific file contents or attributes

**Practical use cases for `Be()` method:**
1. Validating overall project structure
2. Checking file size quotas or limits
3. Verifying file permissions across the entire file system
4. Ensuring no prohibited file types exist
5. Validating naming conventions across multiple files/directories

### 1) Пользовательская проверка коренной папки
```csharp
public static IFileSystemAssertion Be(this IFileSystemAssertion assertion, Predicate<string> predicate)
```
Позволяет выполнить пользовательскую проверку с помощью указанного предиката. Предикат получает полный путь к файлу или директории.

*Этот метод также можно использовать для создания кастомных методов расширения для ассертов, хотя все же рекомендуется использовать низкоуровневый Validate() о котором будет рассказано далее, из-за невозможности контролировать сообщение об ошибке*


**Пример:**
```csharp
_fileSystem.Should().ItemBe("data.csv", path => 
{
    var content = File.ReadAllText(path);
    return content.Contains("Total") && content.EndsWith("\n");
});
```

## Проверки содержимого директорий

### 1) Проверка что директория содержит файл по имени
```csharp
public static IFileSystemAssertion DirectoryContainsFile(
    this IFileSystemAssertion assertion,
    string rootRelativePath,
    string fileName,
    SearchOption searchOption = SearchOption.TopDirectoryOnly)
```
Проверяет что директория содержит файл с указанным именем.

**Пример:**
```csharp
_fileSystem.Should().DirectoryContainsFile("logs", "app.log", SearchOption.AllDirectories);
```

### 2) Проверка что директория содержит поддиректорию по имени
```csharp
public static IFileSystemAssertion DirectoryContainsSubdirectory(
    this IFileSystemAssertion assertion,
    string rootRelativePath,
    string directoryName,
    SearchOption searchOption = SearchOption.TopDirectoryOnly)
```
Проверяет что директория содержит поддиректорию с указанным именем.

**Пример:**
```csharp
_fileSystem.Should().DirectoryContainsSubdirectory("project", "src", SearchOption.AllDirectories);
```

### 3) Проверка что директория содержит все указанные файлы
```csharp
public static IFileSystemAssertion DirectoryContainsAllFiles(
    this IFileSystemAssertion assertion,
    string rootRelativePath,
    params string[] fileNames)
```
Проверяет что директория содержит все файлы из указанного списка.

**Пример:**
```csharp
_fileSystem.Should().DirectoryContainsAllFiles("config", "appsettings.json", "web.config");
```

### 4) Проверка что директория содержит ровно указанные файлы
```csharp
public static IFileSystemAssertion DirectoryContainsExactlyFiles(
    this IFileSystemAssertion assertion,
    string rootRelativePath,
    params string[] fileNames)
```
Проверяет что директория содержит ровно указанные файлы и никаких других.

**Пример:**
```csharp
_fileSystem.Should().DirectoryContainsExactlyFiles("bin", "app.dll", "app.pdb");
```

### 5) Проверка что все файлы в директории удовлетворяют предикату
```csharp
public static IFileSystemAssertion AllFilesInDirectorySatisfy(
    this IFileSystemAssertion assertion,
    string rootRelativePath,
    Predicate<string> predicate)
```
Проверяет что все файлы в директории удовлетворяют указанному предикату.

**Пример:**
```csharp
_fileSystem.Should().AllFilesInDirectorySatisfy("logs", fileName => fileName.EndsWith(".log"));
```

### 6) Проверка что директория содержит хотя бы один файл удовлетворяющий предикату
```csharp
public static IFileSystemAssertion DirectoryContainsFileSatisfying(
    this IFileSystemAssertion assertion,
    string rootRelativePath,
    Predicate<string> predicate)
```
Проверяет что директория содержит хотя бы один файл, удовлетворяющий указанному предикату.

**Пример:**
```csharp
_fileSystem.Should().DirectoryContainsFileSatisfying("data", fileName => fileName.Contains("backup"));
```

### 7) Проверка количества поддиректорий
```csharp
public static IFileSystemAssertion DirectoryHasSubdirectoryCount(
    this IFileSystemAssertion assertion,
    string rootRelativePath,
    int expectedCount)
```
Проверяет что директория содержит указанное количество поддиректорий.

**Пример:**
```csharp
_fileSystem.Should().DirectoryHasSubdirectoryCount("project", 3);
```

### 8) Проверка что все файлы имеют указанные расширения
```csharp
public static IFileSystemAssertion AllFilesHaveExtensions(
    this IFileSystemAssertion assertion,
    string rootRelativePath,
    params string[] extensions)
```
Проверяет что все файлы в директории имеют одно из указанных расширений.

**Пример:**
```csharp
_fileSystem.Should().AllFilesHaveExtensions("source", ".cs", ".csproj");
```

## Примеры использования

### Пример 1: Комплексная проверка конфигурации приложения
```csharp
[Fact]
public void ApplicationConfiguration_ShouldBeValid()
{
    _fileSystem.Should()
        .FileExists("appsettings.json")
        .FileContains("appsettings.json", "\"ConnectionStrings\"")
        .FileMatchesRegex("appsettings.json", "\"Logging\"\\s*:")
        .DirectoryExists("logs")
        .DirectoryHasFileCount("logs", 3)
        .DirectoryContainsFileWithExtension("logs", ".log");
}
```

### Пример 2: Проверка временных файлов
```csharp
[Fact]
public void TemporaryFiles_ShouldBeCleanedUp()
{
    _fileSystem.Should()
        .NotContains("temp-data.tmp")
        .NotContains("cache.bin")
        .HasNoDirectoryContent("temp")
        .FileExists("permanent-config.xml")
        .FileContentEquals("permanent-config.xml", "<config></config>");
}
```

### Пример 3: Проверка структуры проекта
```csharp
[Fact]
public void ProjectStructure_ShouldBeCorrect()
{
    _fileSystem.Should()
        .DirectoryExists("src")
        .DirectoryExists("tests")
        .FileExists("README.md")
        .FileExists("LICENSE")
        .FileExists(".gitignore")
        .FileContains("README.md", "# Project Name")
        .DirectoryContainsAllFiles("src", "Program.cs", "Startup.cs")
        .AllFilesHaveExtensions("src", ".cs");
}
```

### Пример 4: Проверка безопасности файлов
```csharp
[Fact]
public void SecurityFiles_ShouldHaveCorrectPermissions()
{
    _fileSystem.Should()
        .FileHasAttributes("secret.key", FileAttributes.ReadOnly)
        .FileDoesNotHaveAttributes("public.txt", FileAttributes.ReadOnly)
        .FileExists("admin-credentials.txt")
        .FileHasAttributes("admin-credentials.txt", FileAttributes.Hidden);
}
```


Использование этих ассертов делает тесты более выразительными и поддерживаемыми, а также упрощает диагностику проблем при падении тестов.