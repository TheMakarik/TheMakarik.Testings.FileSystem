
# 6. Работа с tar-архивами (.tar, .tar.gz, .tar.bz2)

`TheMakarik.Testing.FileSystem.SharpCompress` позволяет удобно создавать и проверять tar-архивы (включая сжатые варианты .tar.gz и .tar.bz2) прямо в интеграционных тестах. Это полезно при тестировании компонентов, которые работают с архивами в формате tar — например, бэкапов, дистрибутивов, Docker-контекстов и т.д.

Поддерживается создание архивов с помощью fluent-API и проверка их содержимого через метод `.ShouldTar()`.

## Установка

Библиотека для работы с этим форматом архивов поставляется отдельно, из за зависимости от `SharpCompress`, для установки выполните следующую команду:

```bash
dotnet add package TheMakarik.Testing.FileSystem.SharpCompress
```

## Создание tar-архивов

### Основные методы

Все методы расширения находятся в пространстве имён:

```csharp
using TheMakarik.Testing.FileSystem.SharpCompress.Tar;
```

#### 1. Добавление одного tar-архива

```csharp
.AddTar(string name, Func<TarFileSystemBuilder, TarFileSystemBuilder> buildContentLazy, TarPackTo tarPackTo = TarPackTo.None, int? compressionLevel = null)
```

- `name` — имя архива (относительно корня). Расширение нормализуется автоматически.
- `buildContentLazy` — функция для добавления файлов и папок внутрь архива.
- `tarPackTo` — тип сжатия: `None` (.tar), `GZip` (.tar.gz), `BZip` (.tar.bz2).
- `compressionLevel` — уровень сжатия (1–9) — работает **только** для `GZip`.

**Пример простого архива:**

```csharp
_fileSystem = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddTar("backup.tar", tar => tar
        .AddFile("readme.txt", "Это резервная копия")
        .AddFile("config.json", "{ \"version\": \"1.0\" }")
        .AddDirectory("logs", logs => logs
            .AddFile("app.log", "2026-02-07 INFO Started"))
    )
    .Build();
```

#### 2. Получение полного пути к архиву

```csharp
.AddTar(string name, out string fullPath, Func<TarFileSystemBuilder, TarFileSystemBuilder> buildContentLazy, TarPackTo tarPackTo = TarPackTo.None, int? compressionLevel = null)
```

**Пример:**

```csharp
string tarPath;
_fileSystem = FileSystem.BeginBuilding()
    .AddTar("project.tar.gz", out tarPath, tar => tar
        .AddFiles(new[] { "Program.cs", "Startup.cs" }, "// C# code")
        .AddDirectory("wwwroot", www => www.AddFile("index.html", "<h1>Hello</h1>"))
    , TarPackTo.GZip, compressionLevel: 6)
    .Build();
```

#### 3. Добавление нескольких одинаковых архивов

```csharp
.AddTars(string[] names, Func<TarFileSystemBuilder, TarFileSystemBuilder> buildContentLazy, TarPackTo tarPackTo = TarPackTo.None, int? compressionLevel = null)
.AddTars(string[] names, out string[] fullPaths, Func<TarFileSystemBuilder, TarFileSystemBuilder> buildContentLazy, TarPackTo tarPackTo = TarPackTo.None, int? compressionLevel = null)
```

**Пример:**

```csharp
_fileSystem = FileSystem.BeginBuilding()
    .AddTars(new[] { "daily.tar.gz", "weekly.tar.gz" }, tar => tar
        .AddFile("backup.log", "Backup completed at " + DateTime.Now), TarPackTo.GZip)
    .Build();
```

## Добавление содержимого в tar (методы расширения для ITarFileSystemBuilder)

```csharp
tar.AddFile("file.txt")                     // пустой файл
tar.AddFile("config.json", "{...}")         // с содержимым
tar.AddFile("data.csv", out string path, "header,data")  // + путь
tar.AddFiles(["a.txt", "b.txt"], "content") // несколько с одинаковым содержимым
tar.AddFile("binary.dat", stream)           // содержимое из Stream
tar.AddFile("binary.dat", out var entryPath, stream) // содержимое из Stream + путь
tar.AddFiles(["a.bin", "b.bin"], stream)   // несколько файлов из одного Stream
tar.AddDirectory("src", src => src
    .AddFiles(["Program.cs", "Program.cs"], "// code"))
```

Все методы поддерживают цепочку вызовов и автоматически используют префикс при вложенных директориях.

## Автогенерация имён внутри tar-архива

Точно так же, как и для обычной файловой системы (`docs/ru/5.Автогенерация имен.md`), для содержимого tar-архива можно включить автогенерацию имён файлов и директорий.

Методы находятся в пространстве имён:

```csharp
using TheMakarik.Testing.FileSystem.SharpCompress.Tar.AutoNaming;
```

### Подключение генератора имён

```csharp
tar.AddNameGenerator(NameGenerationType.RandomNameAndCount /* или любой другой тип */, seed: 42)
   // далее можно вызывать методы автонейминга
   .AddFileWithNameGenerating(".log", "log content");
```

- `NameGenerationType` — тот же enum, что и для обычной ФС (см. общую главу про автонейминг).
- `seed` (необязательный) — фиксирует последовательность для детерминированных тестов.

### Методы автонейминга для tar

После вызова `AddNameGenerator` становятся доступны методы:

```csharp
// один файл
tar.AddFileWithNameGenerating(".txt", "Hello");

// один файл + относительный путь внутри архива
tar.AddFileWithNameGenerating(".txt", out string entryPath, "Hello");

// несколько файлов с одинаковым содержимым
tar.AddFilesWithNameGenerating(".json", 10, "{ \"ok\": true }");

// одна директория с автосгенерированным именем
tar.AddDirectoryWithNameGenerating(inner =>
    inner.AddFile("readme.txt", "inside auto-named dir"));

// директория + относительный путь
tar.AddDirectoryWithNameGenerating(out string dirPath, inner =>
    inner.AddFile("readme.txt", "inside auto-named dir"));
```

Сбросить счётчики (начать генерацию имён «с нуля») можно методом:

```csharp
tar.RefreshGenerator();
```

Это удобно, когда внутри одного и того же архива нужно создать несколько логических групп файлов с независимой нумерацией.

## Проверка содержимого tar-архивов

Метод расширения:

```csharp
_fileSystem.ShouldTar(string rootRelativeTarArchiveName)
```

Автоматически распаковывает архив во временную папку и возвращает обычный `IFileSystemAssertion` для проверки содержимого.

**Поддерживаемые форматы:** .tar, .tar.gz, .tar.bz2 (SharpCompress сам определяет тип).

**Пример проверки:**

```csharp
[Fact]
public void BackupTar_ShouldContainLogs()
{
    _fileSystem.ShouldTar("backup.tar.gz")
        .DirectoryExists("logs")
        .FileExists("logs/app.log")
        .FileContentEquals("logs/app.log", "2026-02-07 INFO Started")
        .FileExists("readme.txt")
        .TotalFileCount(3);
}
```

**Важно:** временная папка с распакованным содержимым удаляется автоматически при вызове `Dispose()` у исходного `_fileSystem`.

## Полные примеры

### Пример 1 — Тестирование бэкапа базы данных

```csharp
var fs = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddTar("db-backup.tar.gz", tar => tar
        .AddFile("dump.sql", "CREATE TABLE users ...")
        .AddFile("metadata.json", "{ \"date\": \"2026-02-07\" }")
        .AddDirectory("schemas", s => s
            .AddFile("users.sql", "CREATE TABLE ..."))
    , TarPackTo.GZip, compressionLevel: 9)
    .Build();

fs.ShouldTar("db-backup.tar.gz")
    .FileExists("dump.sql")
    .FileContains("dump.sql", "CREATE TABLE users")
    .DirectoryExists("schemas")
    .DirectoryHasFileCount("schemas", 1);
```

### Пример 2 — Несколько архивов с разными уровнями сжатия

```csharp
fs = FileSystem.BeginBuilding()
    .AddTar("fast.tar.gz", t => t.AddFile("large.log", new string('x', 100000)), TarPackTo.GZip, 1)
    .AddTar("best.tar.gz", t => t.AddFile("large.log", new string('x', 100000)), TarPackTo.GZip, 9)
    .Build();

fs.ShouldTar("fast.tar.gz")
    .FileContentEquals("large.log", new string('x', 100000));
```

### Пример 3 — Проверка вложенной структуры

```csharp
fs.ShouldTar("project.tar")
    .DirectoryExists("src")
    .DirectoryExists("src/Models")
    .FileExists("src/Program.cs")
    .FileExists("README.md")
    .AllFilesHaveExtensions("src", ".cs");
```

## Важные замечания

- **Автоматическая нормализация расширений** — не нужно вручную писать `.tar.gz`, библиотека добавит нужное.
- **Очистка при ошибках** — если при создании архива произойдёт исключение, частично созданный файл будет удалён.
- **Сжатие** — уровень сжатия работает только для GZip. BZip2 использует фиксированный уровень.
- **Пути в архиве** — всегда используют `/` (даже на Windows).
- **Ограничения** — tar не хранит пустые директории явно, поэтому проверяйте их наличие через наличие вложенных файлов.

Использование tar-поддержки делает тесты архиваторов, бэкап-систем и CI/CD-пайплайнов значительно проще и выразительнее.
