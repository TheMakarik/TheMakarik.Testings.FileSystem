# Работа с ZIP архивами в TheMakarik.Testing.FileSystem

`TheMakarik.Testing.FileSystem` предоставляет удобный интерфейс для создания и проверки содержимого ZIP архивов в интеграционных тестах. Это позволяет тестировать сценарии, связанные со сжатыми файлами и архивами, без необходимости вручную создавать и извлекать архивы.

## Создание ZIP архивов

### Основной метод `AddZip`

Для создания ZIP архивов используется метод расширения `AddZip`, который добавляет архив в файловую систему.

#### 1) Создание ZIP архива
```csharp
public static IFileSystemBuilder AddZip(
    this IFileSystemBuilder builder, 
    string archiveName, 
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder>? builderAction)
```

Создает ZIP архив с указанным именем в файловой системе. Если `builderAction` не указан, создается пустой архив.

**Пример:**
```csharp
_fileSystem = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddZip("data.zip", zipBuilder => zipBuilder
        .AddFile("config.json", "{ \"enabled\": true }")
        .AddDirectory("logs", logsBuilder => logsBuilder
            .AddFile("app.log", "Log content")))
    .Build();
```

#### 2) Создание ZIP архива с получением полного пути
```csharp
public static IFileSystemBuilder AddZip(
    this IFileSystemBuilder builder, 
    string archiveName, 
    out string archiveFullPath,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder>? builderAction)
```

Создает ZIP архив и возвращает полный путь к архиву через параметр `out`.

**Пример:**
```csharp
string zipPath;
_fileSystem = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddZip("archive.zip", out zipPath, zipBuilder => zipBuilder
        .AddFile("readme.txt", "Archive content"))
    .Build();
```

### Создание нескольких ZIP архивов

#### 3) Создание нескольких ZIP архивов
```csharp
public static IFileSystemBuilder AddZips(
    this IFileSystemBuilder builder,
    string[] archiveNames,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder>? builderAction = null)
```

Создает несколько ZIP архивов с одинаковой структурой содержимого.

**Пример:**
```csharp
_fileSystem = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddZips(["backup.zip", "data.zip", "logs.zip"], zipBuilder => zipBuilder
        .AddFile("metadata.txt", "Created: " + DateTime.Now))
    .Build();
```

#### 4) Создание нескольких ZIP архивов с получением путей
```csharp
public static IFileSystemBuilder AddZips(
    this IFileSystemBuilder builder,
    string[] archiveNames,
    out string[] archiveFullPaths,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder>? builderAction = null)
```

Создает несколько ZIP архивов и возвращает массив полных путей к архивам.

**Пример:**
```csharp
string[] archivePaths;
_fileSystem = FileSystem.BeginBuilding()
    .AddRandomInTempRootName()
    .AddZips(["archive1.zip", "archive2.zip"], out archivePaths, zipBuilder => zipBuilder
        .AddFile("info.txt", "Archive data"))
    .Build();
```

## Автогенерация имён ZIP архивов

Если в файловой системе уже настроен авто-нейминг (см. `5.Автогенерация имен.md`), можно автоматически генерировать имена для ZIP-архивов.

```csharp
using TheMakarik.Testing.FileSystem.AutoNaming;
using TheMakarik.Testing.FileSystem.Zip;
```

### 1) Один ZIP архив

```csharp
builder
    .AddNameGenerator(NameGenerationType.RandomNameAndCount)
    .AddZipWithNameGenerating(zip => zip
        .AddFile("config.json", "{}"));
```

Имя архива будет сгенерировано автоматически, при этом расширение `.zip` учитывается в генераторе.

Алиас с более «говорящим» именем делает то же самое:

```csharp
builder
    .AddNameGenerator(NameGenerationType.RandomNameAndCount)
    .AddZipWithAutoNaming(zip => zip
        .AddFile("config.json", "{}"));
```

### 2) Один ZIP архив с получением полного пути

```csharp
builder
    .AddNameGenerator(NameGenerationType.RandomNameAndCount)
    .AddZipWithNameGenerating(out var zipFullPath, zip => zip
        .AddFile("data.txt", "content"));
```

Или через алиас:

```csharp
builder
    .AddNameGenerator(NameGenerationType.RandomNameAndCount)
    .AddZipWithAutoNaming(out var zipFullPath, zip => zip
        .AddFile("data.txt", "content"));
```

### 3) Несколько ZIP архивов

```csharp
builder
    .AddNameGenerator(NameGenerationType.RandomNameAndCount)
    .AddZipsWithNameGenerating(3, zip => zip
        .AddFile("metadata.txt", "info"));
```

### 4) Несколько ZIP архивов с получением путей

```csharp
builder
    .AddNameGenerator(NameGenerationType.RandomNameAndCount)
    .AddZipsWithNameGenerating(2, out var zipPaths, zip => zip
        .AddFile("log.txt", "zip log"));
```

Для удобства доступны эквивалентные методы с префиксом `AutoNaming`:

- `AddZipWithAutoNaming(...)` / `AddZipWithAutoNaming(out string archiveFullPath, ...)`
- `AddZipsWithAutoNaming(int count, ...)` / `AddZipsWithAutoNaming(int count, out string[] archiveFullPaths, ...)`

Все эти методы используют тот же механизм `NamingInfo`, что и для файлов/директорий (счётчик, расширение и т.п.), поэтому группы архивов можно разделять через `RefreshNameGenerator()`.

## Добавление файлов в ZIP архивы

### Добавление отдельных файлов

#### 1) Добавление пустого файла
```csharp
public static IZipArchiveFileSystemBuilder AddFile(
    this IZipArchiveFileSystemBuilder builder, 
    string fileName, 
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Добавляет пустой файл в ZIP архив с указанным уровнем сжатия.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFile("empty.txt", CompressionLevel.Fastest))
```

#### 2) Добавление файла с содержимым
```csharp
public static IZipArchiveFileSystemBuilder AddFile(
    this IZipArchiveFileSystemBuilder builder, 
    string fileName, 
    string content, 
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Добавляет файл с указанным содержимым в ZIP архив.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFile("config.json", "{ \"key\": \"value\" }", CompressionLevel.Optimal))
```

#### 2.1) Добавление файла из `Stream`
```csharp
public static IZipArchiveFileSystemBuilder AddFile(
    this IZipArchiveFileSystemBuilder builder, 
    string fileName, 
    Stream contentStream, 
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```
Добавляет файл, читая содержимое напрямую из переданного `Stream` (например, из другого файла, сети или памяти).

#### 3) Добавление файла с получением относительного пути
```csharp
public static IZipArchiveFileSystemBuilder AddFile(
    this IZipArchiveFileSystemBuilder builder, 
    string fileName, 
    out string entryRelativePath,
    string content, 
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Добавляет файл и возвращает относительный путь к файлу внутри архива.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFile("data.txt", out string relativePath, "File content"))
// relativePath содержит путь к файлу внутри архива, например: "data.txt"
```

#### 3.1) Добавление файла из `Stream` с получением относительного пути
```csharp
public static IZipArchiveFileSystemBuilder AddFile(
    this IZipArchiveFileSystemBuilder builder, 
    string fileName, 
    out string entryRelativePath,
    Stream contentStream, 
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```
Позволяет добавить файл из потока и одновременно получить относительный путь к нему внутри архива.

### Добавление нескольких файлов

#### 4) Добавление нескольких пустых файлов
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Добавляет несколько пустых файлов в ZIP архив.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFiles(["file1.txt", "file2.txt", "file3.txt"], CompressionLevel.Fastest))
```

#### 5) Добавление нескольких пустых файлов с получением путей
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    out string[] entriesRelativePaths,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Добавляет несколько пустых файлов и возвращает их относительные пути внутри архива.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFiles(["a.txt", "b.txt"], out string[] paths))
// paths содержит ["a.txt", "b.txt"]
```

#### 6) Добавление нескольких файлов с одинаковым содержимым
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    string content,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Добавляет несколько файлов с одинаковым содержимым.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFiles(["log1.txt", "log2.txt"], "Log entry", CompressionLevel.Optimal))
```

#### 7) Добавление нескольких файлов с содержимым и получением путей
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    out string[] entriesRelativePaths,
    string content,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```

Добавляет несколько файлов с одинаковым содержимым и возвращает их относительные пути.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddFiles(["data1.csv", "data2.csv"], out string[] paths, "csv,data"))
```

#### 8) Добавление нескольких файлов с одинаковым содержимым из `Stream`
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    Stream contentStream,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```
Позволяет добавить несколько файлов в архив, записав во все один и тот же поток данных.

#### 9) Добавление нескольких файлов из `Stream` с получением относительных путей
```csharp
public static IZipArchiveFileSystemBuilder AddFiles(
    this IZipArchiveFileSystemBuilder builder,
    string[] fileNames,
    out string[] entriesRelativePaths,
    Stream contentStream,
    CompressionLevel compressionLevel = CompressionLevel.Optimal)
```
Создает несколько файлов из потока и возвращает их относительные пути внутри архива.

## Автогенерация имён внутри ZIP архива

Поддерживается автонейминг файлов и директорий внутри ZIP архива по тем же правилам, что и для обычной файловой системы (`docs/ru/5.Автогенерация имен.md`).

Все методы автонейминга находятся в пространстве имён:

```csharp
using TheMakarik.Testing.FileSystem.Zip.AutoNaming;
```

### Подключение генератора имён

```csharp
.AddZip("auto.zip", zip => zip
    .AddNameGenerator(NameGenerationType.RandomNameAndCount /* или другой тип */, seed: 123)
    .AddFileWithNameGenerating(".txt", "Hello from zip"));
```

- `NameGenerationType` — те же стратегии, что и для корневой ФС (случайные имена, счётчики, комбинации расширения и номера и т.п.).
- `seed` — необязательный параметр для детерминированного поведения.

### Методы автонейминга для ZIP

После вызова `AddNameGenerator` можно использовать:

```csharp
// один файл
zip.AddFileWithNameGenerating(".log", "log content");

// один файл + относительный путь внутри архива
zip.AddFileWithNameGenerating(".json", out string entryPath, "{ \"ok\": true }");

// несколько файлов
zip.AddFilesWithNameGenerating(".txt", 50, "same content");

// директория с автосгенерированным именем
zip.AddDirectoryWithNameGenerating(inner =>
    inner.AddFile("readme.txt", "inside auto-named dir"));

// директория + относительный путь
zip.AddDirectoryWithNameGenerating(out string dirPath, inner =>
    inner.AddFile("readme.txt", "inside auto-named dir"));
```

Сбросить состояние генератора (счётчики и накопленную статистику) можно методом:

```csharp
zip.RefreshGenerator();
```

Это позволяет в рамках одного архива создать несколько групп файлов с независимой нумерацией и/или случайными именами.

## Добавление директорий в ZIP архивы

### Добавление отдельных директорий

#### 1) Добавление директории с вложенным содержимым
```csharp
public static IZipArchiveFileSystemBuilder AddDirectory(
    this IZipArchiveFileSystemBuilder builder, 
    string directoryName, 
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder> createDirectory)
```

Добавляет директорию с вложенным содержимым в ZIP архив.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddDirectory("config", dirBuilder => dirBuilder
        .AddFile("settings.json", "{}")
        .AddFile("secrets.env", "KEY=SECRET")))
```

#### 2) Добавление директории с получением относительного пути
```csharp
public static IZipArchiveFileSystemBuilder AddDirectory(
    this IZipArchiveFileSystemBuilder builder, 
    string directoryName, 
    out string directoryRelativePath,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder> createDirectory)
```

Добавляет директорию и возвращает относительный путь к директории внутри архива.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddDirectory("logs", out string logPath, logsBuilder => logsBuilder
        .AddFile("app.log")))
// logPath содержит "logs/"
```

### Добавление нескольких директорий

#### 3) Добавление нескольких директорий
```csharp
public static IZipArchiveFileSystemBuilder AddDirectories(
    this IZipArchiveFileSystemBuilder builder,
    string[] directoryNames,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder> createDirectory)
```

Добавляет несколько директорий с одинаковой структурой содержимого.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddDirectories(["2024-01", "2024-02", "2024-03"], monthBuilder => monthBuilder
        .AddFile("report.txt", "Monthly report")))
```

#### 4) Добавление нескольких директорий с получением путей
```csharp
public static IZipArchiveFileSystemBuilder AddDirectories(
    this IZipArchiveFileSystemBuilder builder,
    string[] directoryNames,
    out string[] directoriesRelativePaths,
    Func<IZipArchiveFileSystemBuilder, IZipArchiveFileSystemBuilder> createDirectory)
```

Добавляет несколько директорий и возвращает их относительные пути внутри архива.

**Пример:**
```csharp
.AddZip("archive.zip", zipBuilder => zipBuilder
    .AddDirectories(["src", "tests", "docs"], out string[] paths, dirBuilder => dirBuilder
        .AddFile("README.md")))
// paths содержит ["src/", "tests/", "docs/"]
```

## Проверка содержимого ZIP архивов

### Метод `ShouldZip`

Для проверки содержимого ZIP архивов используется метод `ShouldZip`, который извлекает архив во временную директорию и создает контекст для ассертов.

```csharp
public static IFileSystemAssertion ShouldZip(
    this IFileSystem fileSystem, 
    string rootRelativeZipArchiveName)
```

Извлекает указанный ZIP архив и возвращает контекст ассертов для проверки содержимого.

**Пример:**
```csharp
[Fact]
public void ZipArchive_ShouldContainRequiredFiles()
{
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZip("data.zip", zipBuilder => zipBuilder
            .AddFile("config.json", "{}")
            .AddDirectory("logs", logsBuilder => logsBuilder
                .AddFile("app.log", "log content")))
        .Build();
    
    fileSystem.ShouldZip("data.zip")
        .FileExists("config.json")
        .DirectoryExists("logs")
        .FileContains("logs/app.log", "log content");
}
```

## Примеры использования

### Пример 1: Тестирование бэкапов
```csharp
[Fact]
public void BackupArchive_ShouldContainAllData()
{
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZip("backup.zip", out string backupPath, zipBuilder => zipBuilder
            .AddFiles(["users.csv", "products.csv"], "CSV data")
            .AddDirectory("logs", logsBuilder => logsBuilder
                .AddFiles(["app.log", "error.log"], "Log entry"))
            .AddDirectory("config", configBuilder => configBuilder
                .AddFile("settings.json", "{\"backup\": true}")))
        .Build();
    
    fileSystem.ShouldZip("backup.zip")
        .TotalFileCount(5)
        .DirectoryExists("logs")
        .DirectoryExists("config")
        .FileExists("users.csv")
        .FileExists("products.csv")
        .FileContains("config/settings.json", "backup");
}
```

### Пример 2: Тестирование сжатия с разными уровнями
```csharp
[Fact]
public void Archive_ShouldUseDifferentCompressionLevels()
{
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZip("archive.zip", zipBuilder => zipBuilder
            .AddFile("fast.txt", "Fast compression", CompressionLevel.Fastest)
            .AddFile("optimal.txt", "Optimal compression", CompressionLevel.Optimal)
            .AddFile("small.txt", "No compression", CompressionLevel.NoCompression))
        .Build();
    
    fileSystem.ShouldZip("archive.zip")
        .FileExists("fast.txt")
        .FileExists("optimal.txt")
        .FileExists("small.txt")
        .FileContentEquals("fast.txt", "Fast compression")
        .FileContentEquals("optimal.txt", "Optimal compression")
        .FileContentEquals("small.txt", "No compression");
}
```

### Пример 3: Тестирование сложной структуры архивов
```csharp
[Fact]
public void MultiArchive_ProjectStructure()
{
    string[] archivePaths;
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZips(["source.zip", "docs.zip", "tests.zip"], out archivePaths, zipBuilder => zipBuilder
            .AddDirectory("src", srcBuilder => srcBuilder
                .AddFiles(["Program.cs", "Startup.cs"], "C# code", CompressionLevel.Optimal)
                .AddDirectory("Models", modelsBuilder => modelsBuilder
                    .AddFile("User.cs", "public class User {}")))
            .AddFile("README.md", "Project documentation"))
        .Build();
    
    // Проверка первого архива
    fileSystem.ShouldZip("source.zip")
        .DirectoryExists("src")
        .DirectoryExists("src/Models")
        .FileExists("src/Program.cs")
        .FileExists("src/Models/User.cs")
        .FileExists("README.md");
}
```

### Пример 4: Тестирование с вложенными архивами
```csharp
[Fact]
public void NestedArchiveStructure_ShouldBeValid()
{
    var fileSystem = FileSystem.BeginBuilding()
        .AddRandomInTempRootName()
        .AddZip("project.zip", zipBuilder => zipBuilder
            .AddDirectory("2024", yearBuilder => yearBuilder
                .AddDirectories(["Q1", "Q2", "Q3", "Q4"], quarterBuilder => quarterBuilder
                    .AddFiles(["report.pdf", "data.xlsx"], "Quarter data")))
            .AddFile("summary.txt", "Annual summary"))
        .Build();
    
    fileSystem.ShouldZip("project.zip")
        .DirectoryExists("2024")
        .DirectoryExists("2024/Q1")
        .DirectoryExists("2024/Q2")
        .DirectoryExists("2024/Q3")
        .DirectoryExists("2024/Q4")
        .FileExists("2024/Q1/report.pdf")
        .FileExists("2024/Q2/data.xlsx")
        .FileExists("summary.txt")
        .TotalFileCount(9); // 4 квартала × 2 файла + summary.txt
}
```

## Важные примечания

1. **Автоматическая очистка**: Временные директории, созданные при извлечении архивов через `ShouldZip`, автоматически очищаются при вызове `Dispose()` у родительской файловой системы.

2. **Относительные пути**: Все методы с `out` параметрами возвращают относительные пути внутри архива, а не абсолютные пути к файлам.

3. **Уровни сжатия**: Можно указывать разные уровни сжатия для разных файлов в архиве:
   - `CompressionLevel.Fastest` - быстрое сжатие (меньшая степень сжатия)
   - `CompressionLevel.Optimal` - оптимальное сжатие (баланс скорости и размера)
   - `CompressionLevel.NoCompression` - без сжатия

4. **Обработка ошибок**: При создании архивов, если возникает исключение, созданные части архива автоматически удаляются для предотвращения загрязнения файловой системы.

5. **Fluent интерфейс**: Все методы поддерживают цепочку вызовов, что делает код более читаемым и выразительным.

Использование этих методов значительно упрощает тестирование сценариев, связанных с ZIP архивами, делая тесты более читаемыми и поддерживаемыми.